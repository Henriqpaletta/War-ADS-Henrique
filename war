#include <stdio.h>
#include <stdlib.h> // Para malloc, calloc, free e rand/srand
#include <string.h> // Para strcpy
#include <time.h>   // Para time (usado com srand)

// Struct: Estrutura para representar um Territ√≥rio.
struct Territorio {
    char nome[30];
    char cor[10];
    int tropas;
};

// Prot√≥tipos das Fun√ß√µes
void cadastrarTerritorios(struct Territorio *mapa, int numTerritorios);
void exibirTerritorios(struct Territorio *mapa, int numTerritorios);
void atacar(struct Territorio *atacante, struct Territorio *defensor);
void liberarMemoria(struct Territorio *mapa);
int rolarDado(); // Fun√ß√£o auxiliar para rolar um dado de 6 lados

// Fun√ß√£o auxiliar para simular a rolagem de um dado (1 a 6).
int rolarDado() {
    return (rand() % 6) + 1;
}

// Preenche os dados do vetor de territ√≥rios.
void cadastrarTerritorios(struct Territorio *mapa, int numTerritorios) {
    int i;
    for (i = 0; i < numTerritorios; i++) {
        printf("--- Cadastro do Territ√≥rio %d de %d ---\n", i + 1, numTerritorios);

        printf("Nome: ");
        scanf("%29s", (mapa + i)->nome);

        printf("Cor do Ex√©rcito: ");
        scanf("%9s", (mapa + i)->cor);

        // Garante que o territ√≥rio comece com pelo menos 1 tropa
        do {
            printf("Tropas (min 1): ");
            scanf("%d", &(mapa + i)->tropas);
        } while ((mapa + i)->tropas < 1);

        printf("\n");
    }
}

// Exibe as informa√ß√µes de todos os territ√≥rios.
void exibirTerritorios(struct Territorio *mapa, int numTerritorios) {
    int i;
    printf("\n======================================================\n");
    printf("üìä STATUS ATUAL DOS TERRIT√ìRIOS:\n");
    printf("======================================================\n");
    for (i = 0; i < numTerritorios; i++) {
        // Exibe o √≠ndice [i] para facilitar a escolha no ataque
        printf("[%d] Nome: %s\n", i, (mapa + i)->nome);
        printf("    Cor: %s\n", (mapa + i)->cor);
        printf("    Tropas: %d\n", (mapa + i)->tropas);
        printf("------------------------------------------------------\n");
    }
}

// Simula um ataque entre dois territ√≥rios e atualiza seus dados.
void atacar(struct Territorio *atacante, struct Territorio *defensor) {
    // Requisito: O atacante precisa de pelo menos 2 tropas (1 para o ataque + 1 para ficar)
    if (atacante->tropas < 2) {
        printf("\nüõë O territ√≥rio %s precisa de pelo menos 2 tropas para atacar!\n", atacante->nome);
        return;
    }
    
    // Assegura que o defensor tenha tropas
    if (defensor->tropas < 1) {
        printf("\nüõë O territ√≥rio defensor %s est√° sem tropas e √© conquistado automaticamente!\n", defensor->nome);
        // Regra de Conquista R√°pida (para simplicidade)
        strcpy(defensor->cor, atacante->cor);
        defensor->tropas = 1;
        atacante->tropas -= 1;
        printf("‚ú® %s agora √© %s e recebeu 1 tropa de ocupa√ß√£o.\n", defensor->nome, defensor->cor);
        return;
    }

    printf("\n--- SIMULA√á√ÉO DE BATALHA ---\n");
    printf("üõ°Ô∏è %s (%s) ataca %s (%s)!\n", atacante->nome, atacante->cor, defensor->nome, defensor->cor);

    // Rolagem de dados (um dado para cada lado)
    int dadoAtacante = rolarDado();
    int dadoDefensor = rolarDado();

    printf("üé≤ Dados Rolados: Atacante (%d) vs Defensor (%d)\n", dadoAtacante, dadoDefensor);

    // Se o atacante vencer (dado maior)
    if (dadoAtacante > dadoDefensor) {
        printf("‚úÖ Atacante VENCEU! %s conquistou %s.\n", atacante->nome, defensor->nome);

        // L√≥gica de Transfer√™ncia de Tropas (Corrigida):
        // 1. O atacante deve manter pelo menos 1 tropa no seu territ√≥rio original.
        int tropasDisponiveis = atacante->tropas - 1; 
        int tropasTransferidas = tropasDisponiveis / 2; // Transfere metade do que est√° dispon√≠vel para mover
        
        // Garante que o atacante mova pelo menos 1 tropa se for poss√≠vel
        if (tropasTransferidas < 1 && tropasDisponiveis >= 1) {
            tropasTransferidas = 1;
        }

        // 2. O defensor muda de dono (copia a cor do atacante)
        strcpy(defensor->cor, atacante->cor);

        // 3. Atualiza as tropas
        defensor->tropas = tropasTransferidas;
        atacante->tropas -= tropasTransferidas;

        printf("‚ú® %s agora √© %s e recebeu %d tropas de refor√ßo.\n", defensor->nome, defensor->cor, tropasTransferidas);
        printf("   %s restou com %d tropas.\n", atacante->nome, atacante->tropas);

    } else { // Se o atacante perder ou empatar
        printf("‚ùå Atacante PERDEU ou EMPATOU. Defensor manteve o controle.\n");

        // O atacante perde uma tropa
        atacante->tropas -= 1;
        printf("üî• %s perdeu 1 tropa e agora tem %d.\n", atacante->nome, atacante->tropas);
    }
}

// Libera a mem√≥ria alocada dinamicamente.
void liberarMemoria(struct Territorio *mapa) {
    if (mapa != NULL) {
        free(mapa);
        printf("\n‚úÖ Mem√≥ria alocada liberada com sucesso.\n");
    }
}

// Fun√ß√£o principal do programa
int main() {
    // Inicializa o gerador de n√∫meros aleat√≥rios
    srand(time(NULL));

    struct Territorio *mapa = NULL;
    int numTerritorios = 0;
    int escolhaAtacante, escolhaDefensor;
    
    printf("üåé === War Estruturado: N√≠vel Aventureiro (REVISADO) === ‚öîÔ∏è\n");

    printf("Quantos territ√≥rios voc√™ deseja cadastrar? (Min 2): ");
    scanf("%d", &numTerritorios);

    if (numTerritorios < 2) {
        printf("üõë N√∫mero de territ√≥rios insuficiente. Encerrando o programa.\n");
        return 1;
    }

    // Aloca√ß√£o de mem√≥ria
    mapa = (struct Territorio*) calloc(numTerritorios, sizeof(struct Territorio));

    if (mapa == NULL) {
        printf("üõë Erro ao alocar mem√≥ria. Encerrando.\n");
        return 1;
    }

    // 1. Cadastro dos territ√≥rios
    cadastrarTerritorios(mapa, numTerritorios);

    // 2. Loop de Ataques
    char continuarAtaque;
    do {
        exibirTerritorios(mapa, numTerritorios);

        printf("\n--- Configurar Ataque ---\n");
        printf("Digite o √çNDICE do territ√≥rio ATACANTE (0 a %d): ", numTerritorios - 1);
        scanf("%d", &escolhaAtacante);

        printf("Digite o √çNDICE do territ√≥rio DEFENSOR (0 a %d): ", numTerritorios - 1);
        scanf("%d", &escolhaDefensor);

        // Valida√ß√£o b√°sica de √≠ndices e territ√≥rios iguais
        if (escolhaAtacante < 0 || escolhaAtacante >= numTerritorios ||
            escolhaDefensor < 0 || escolhaDefensor >= numTerritorios ||
            escolhaAtacante == escolhaDefensor) {
            printf("üõë Escolha de √≠ndice inv√°lida ou territ√≥rios iguais. Tente novamente.\n");
            // Limpa o buffer para o pr√≥ximo scanf
            continue; 
        }
        
        struct Territorio *atacante = mapa + escolhaAtacante;
        struct Territorio *defensor = mapa + escolhaDefensor;

        // Valida√ß√£o: n√£o pode atacar territ√≥rio da mesma cor
        if (strcmp(atacante->cor, defensor->cor) == 0) {
            printf("üõë N√£o √© poss√≠vel atacar um territ√≥rio da mesma cor (%s). Tente novamente.\n", atacante->cor);
            continue; 
        }

        // 3. Simula√ß√£o de Ataque
        atacar(atacante, defensor);

        printf("\nDeseja realizar outro ataque? (s/n): ");
        // CORRE√á√ÉO: Adiciona um espa√ßo antes do %c para ignorar o caractere '\n' pendente
        scanf(" %c", &continuarAtaque);

    } while (continuarAtaque == 's' || continuarAtaque == 'S');


    // 4. Libera√ß√£o de mem√≥ria
    liberarMemoria(mapa);
    
    printf("\nPrograma finalizado. At√© o pr√≥ximo desafio! üéâ\n");

    return 0;
}
